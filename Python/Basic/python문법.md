## 자료형
- 모든 프로그래밍은 결국 데이터를 다루는 행위
  - 자료형에 대한 이해는 프로그래밍의 길에 있어서의 첫걸음
- 파이썬의 자료형으로는 정수형,실수형,복소수형,문자열,리스트,튜플,사전 등이 있다.
  - 파이썬의 자료형은 필수적으로 알아 두어야 한다.

## 정수형
- 정수형(Integer)은 정수를 다루는 자료형
  - 양의정수,음의정수,0이 포함된다.
- 코테에서 출제되는 많은 문제들은 정수형을 주로 다루게 된다.

```python
# 양의 정수
a = 1000
print(a)
# 실행결과 1000

# 음의 정수
a = -7
print(a)
# 실행결과 -7

# 0
a = 0
print(a)  
# 실행결과 0
```

## 실수형
- 실수형(Real Number)은 소수점 아래의 데이터를 포함하는 수 자료형
  - 파이썬에서는 변수에 소수점을 붙인 수를 대입하면 실수형 변수로 처리
  - 소수부가 0이거나 , 정수부가 0인 소수는 0을 생략하고 작성할 수 있다

```python
# 양의 실수
a = 157.93
print(a)
# 실행결과 157.93

# 음의 실수
a = -1837.2
print(a)
# 실행결과 -1837.2

# 소수부가 0일 때 0을 생략
a = 5.
print(a)
# 실행결과 5.0

# 정수부가 0일 때 0을 생략
a = -.7
print(a)
#실행결과 -0.7
```

## 지수표현방식
- 파이썬에서든 e 나 E를 이용한 지수표현방식을 이용할 수 있다.
  - e나 E 다음에 오는 수는 10의 지수부를 의미
  - 예를들어 1e9라고 입력하게 되면 10의 9제곱(1,000,000,000)이 된다
- `유효숫자e지수 = 유효숫자 * 10지수`
- 지수표현방식은 임의의 큰 수를 표현하기 위해 자주 사용
- 최단 경로 알고리즘에서는 도달할 수 없는 노드에 대하여 최단거리를 무한(INF)로 설정하곤 한다
- 이때 가능한 최대값이 10억 미만이라면 무한의 값으로 1e9를 이용할 수 있다
- 실수형 데이터로 처리됨을 기억

```python
# 1,000,000,000의 지수표현방식
a = 1e9
print(a)
# 실행결과 1000000000.0

# 752.5
a = 75.25e1
print(a)
# 실행결과 752.5

# 3.954
a = 3954e-3
print(a)
# 실행결과 3.954
```
- 만약 문제에서 정수형 데이터를 처리한다고 하면, 가능한 오류가 발생하지 않게 하기 위해서 내장함수인 int를 이용해 실수를 정수데이터로 바꾸어 처리할 수 있게 바꾸어준다.
- 오늘날 가장 널리 쓰이는 IEEE754 표준에서는 실수형을 저장하기 위해 4바이트 혹은 8바이트의 고정된 크기의 메모리를 할당하므로, 컴퓨터 시스템은 실수 정보를 표현하는 정확도에 한계를 가진다.
- 예를들어 10진수 체계에서는 0.3과 0.6을 더한 값이 0.9 이다
  - 하지만 2진수에서는 0.9를 정확히 표현할 수 있는 방법이 없다
  - 컴퓨터는 최대한 0.9와 가깝게 표현하겠지만 미세한 오차가 발생하게 된다.

```python
a = 0.3 + 0.6
print (a)

if a == 0.9:
    print(True)
else:
    print(False)

# 실행결과 0.8999999999999
#        False
```
- 개발과정에서 실수 값을 제대로 비교하지 못해서 원하는 결과를 얻지 못할 수 있다.
- 이럴때 round()함수를 이용할 수 있으며 권장 된다.
- 예를들어 123.456을 소수 셋째 자리에서 반올림하려면 round(123.456,2) 라고 작성한다.
  - 결과는 123.46이 된다.

```python
a = 0.3 + 0.6
print(round(a,4))

if round(a,4) == 0.9:
    print(True)
else:
    print(False)

# 실행결과 0.9
#       True
```

## 수 자료형의 연산
- 수 자료형에 대하여 사칙연산과 나머지 연산자가 많이 사용된다.
- 단 나누기 연산자(/)를 주의해서 사용해야 한다.
  - 파이썬에서 나누기 연산자(/)는 나눠진 결과를 실수형으로 반환한다.
- 다양한 로직을 설계할 때 나머지 연산자(%)를 이용해야 할 때가 많다
  - 예시 a가 홀수 인지 체크해야하는 경우
- 파이썬에서는 몫을 얻기 위해 몫 연산자 (//)를 사용
- 이외에도 거듭 제곱 연산자 (**)를 비롯해 다양한 연산자들이 존재

```python
a = 7
b = 3

# 나누기
print(a/b)
# 실행결과 2.3333333333333335

# 나머지
print(a % b)
# 실행결과 1

# 몫
print(a // b)
# 실행결과 2
```
```python
a = 5
b = 3

# 거듭제곱
print(a ** b)
# 실행결과 125

# 제곱근
print(a ** 0.5)
# 실행결과 2.23606797749979
```

## 라스트 자료형
- 여러개의 데이터를 연속적으로 담아 처리하기 위해 사용하는 자료형
  - 사용자 입장에서 C나 자바에서의 배열(Array)의 기능 및 연결 리스트와 유사한 기능 지원
  - C++의 STL vector와 기능적으로 유사
  - 리스트 대신에 배열 혹은 테이블이라고 부르기도 한다.

## 리스트 초기화
- 리스트 대괄호[] 안에 원소를 넣어 초기화하며, 쉼표로 원소를 구분
- 비어 있는 리스트를 선언하고자 할 때는 list() 혹은 간단히 []를 이용할 수 있음
- 리스트의 원소에 접근할 때는 인덱스 값을 괄호에 넣는다.
  - 인덱스는 0부터 시작

```python
# 직접 데이터를 넣어 초기화
a = [1,2,3,4,5,6,7,8,9]
print(a)
# 실행결과 [1,2,3,4,5,6,7,8,9]

# 네번째 원소만 출력
print(a[3])
# 실행결과 4

# 크기가 N이고, 모든 값이 0인 1차원 리스트 초기화
n = 10
a = [0]*n
prnt(a)
# 실행결과 [0,0,0,0,0,0,0,0,0,0]
```
## 리스트의 인덱싱과 슬라이싱
- 인덱스 값을 입력하여 리스트의 특정한 원소에 접근하는 것을 인덱싱 이라고 한다.
  - 파이썬의 인덱스 값은 양의 정숭와 음의 정수를 모두 사용 가능
  - 음의 정수를 넣으면 원소를 거꾸로 탐색

```python
a = [1,2,3,4,5,6,7,8,9]

# 여덟번째 원소만 출력
print(a[7])
# 실행결과 8

# 뒤에서 첫번째 원소 출력
print(a[-1])
# 실행결과 9

# 뒤에서 세번째 원소 출력
print(a[-3])
# 7

# 네번째 원소 값 변경
a[3] = 7
print(a)
# [1,2,3,7,5,6,7,8,9]
```
---
- 리스트에서 연속적인 위치를 갖는 원소들을 가져와야 할 때는 슬라이싱을 이용한다.
  - 대괄호 안에 콜론을 넣어서 시작 인덱스와 끝 인덱스를 설정할 수 있다.
  - 끝 인덱스는 실제 인덱스보다 1을 더 크게 설정한다.

```python
a = [1,2,3,4,5,6,7,8,9]

# 네번째 원소만 출력
print(a[3])
# 4

# 두번째 원소부터 네번째 원소까지
print(a[1 : 4])
# [2,3,4]
```

## 리스트 컴프리헨션
- 리스트를 초기화하는 방법중 하나
  - 대괄호 안에 조건문과 반목문을 적용하여 리스트를 초기화 가능

```python
# 0~9까지의 수를 포함하는 리스트
array = [i for in range(10)]

print(array)
# [0,1,2,3,4,5,6,7,8,9]
```

```python
# 0~19까지의 수 중에서 홀수만 포함하는 리스트
array = [i for i in range(20) if i % 2 == 1]

print(array)
# [1,3,5,7,9,11,13,15,17,19]

# 일반적 코드
array = []
for i in range(20):
  if i % 2 ==1:
    array.append(i)
      
  print(array)

# 1~9까지의 수들의 제곱 값을 포함하는 리스트
array = [i * i for i in range (1,10) ]

print(array)
# [1,4,9,16,25,36,49,64,81]
```

- 리스트 컴프리헨션은 2차원 리스트를 초기화할 때 효과적으로 사용된다.
- 특히 N X M 크기의 2차원 리스트를 한번에 초기화 해야할 때 매우 유용
  - 좋은예시 = array = [[0]*m for _ in range(n)]
- 만약 2차원 리스트를 초기화할 때 다음과 같이 작성하면 예기치 않은 결과가 나올 수 있다.
  - 잘못된 예시 = array = [[0] * m]*n
  - 위 코드는 전체 리스트 안에 포함된 각 리스트가 모두 같은 객체로 인식

```python
# 좋은예시 
# N X M 크기의 2차원 리스트 초기화
n = 4
m = 3
array = [[0] * m for _ in range(n)]
print(array)

# [[0,0,0],[0,0,0],[0,0,0],[0,0,0]]

# 잘못된 예시
n = 4
m = 3
array = [[0] * m] *  n
print(array)

array[1][1] = 5
print(array)
# [[0,0,0],[0,0,0],[0,0,0],[0,0,0]]
# [[0,5,0],[0,5,0],[0,5,0],[0,5,0]]
# 하나만 바뀌어야 하는데 모든 내부리스트에서 전부다 5로 바뀌게 되는 오류
```
## 언더바는 언제 사용?
- 파이썬에서는 반복을 수행하되 반복을 위한 변수의 값을 무시하고자할 때 언더바를 사용
```python
# 1~9 까지 자연수 더하기
summary = 0
for i in range (1, 10):
        summary += i
print(summary)
# 45
# 매번 자연수를 담아야하기 떄문에 변수 i 사용

for _ in range(5):
  print("Hello World")
# 내부적으로 변수값이 사용되지 않고 반복을 위한 변수가 별도로 사용되지 않고 반복하고자 할 경우

```

## 리스트 관련 기타 메서드
- 변수명.append()
  - 리스트에 원소를 하나 삽입할 때 사용 (시간복잡도 O(1))
- 변수명.sort() ,  변수명.sort(reverse = True)
  - 전자는 기본 정렬기능으로 오름차순 , 후자는 내림차순 정렬 (시간복잡도 O(NlogN))
- 변수명.reverse()
  - 리스트의 원소의 순서를 모두 뒤집어 놓는다 (시간복잡도 O(N))
- insert(삽입할 위치 인덱스,삽입할 값)
  - 특정한 인덱스 위치에 원소를 삽입할 때 사용 (시간복잡도 O(N))
- 변수명.count(특정값)
  - 리스트에서 특정한 값을 가지는 데이터의 개수를 셀 때 사용 (시간복잡도 O(N))
- 변수명.remove(특정값)
  - 특정한 값을 갖는 원소를 제거하는데, 값을 가진 원소가 여러개면 하나만 제거 (시간복잡도 O(N))

```python
a = [1.4.3]
print("기본리스트:", a)
# 기본리스트 : [1,4,3]

# 리스트에 원소 삽입
a.append(2)
print("삽입:",a)
# 삽입: [1,4,3,2]

# 오름차순 정렬
a.sort()
print("오름차순 정렬:",a)
# 오름차순 정렬: [1.2.3.4]

# 내림차순 정렬
a.sort(reverse = True)
print("내림차순 정렬:",a)
# 내림차순 정렬: [4,3,2,1]

a = [4,3,2,1]

# 리스트 원소 뒤집기
a.reverse()
print("원소 뒤집기:",a)
# 원소 뒤집기: [1,2,3,4]

# 특정 인덱스에 데이터 추가
a.insert(2,3)
print("인덱스 2에 3추가:",a)
# 인덱스 2에 3추가: [1,2,3,3,4]

# 특정 값인 데이터 개수 세기
print("값이 3인 데이터 개수:",a.count(3))
# 값이 3인 데이터 개수 : 2

# 특정 값 데이터 삭제
a.remove(1)
print("값이 1인 데이터 삭제:",a)
# 값이 1인 데이터 삭제: [2,3,3,4]

# 리스트에서 특정 값을 가지는 원소를 모두 제거하기
a = [1,2,3,4,5,5,5]
remove_set = {3,5} # 집합 자료형

# remove_list에 포함되지 않은 값만을 저장
result = [i for i in a if i not in remove_set]
print(result)
# [1,2,4]
```

## 문자열 자료형
- 문자열 변수를 초기화할 때는 큰따옴표나 작은 따옴표를 이용
- 문자열 안에 큰따옴표나 작은따옴표가 포함되어야 하는 경우가 있다
  - 전체 문자열을 큰따옴표로 구성하는경우, 내부적으로 작은 따옴표를 포함할 수 있다.
  - 전체 문자열을 작은따옴표로 구성하는 경우, 내부적으로 큰따옴표를 포함할 수 있다.
  - 혹은 백슬래시(\)룰 사용하면, 큰따옴표나 작은따옴표를 원하는 만큼 포할시킬 수 있다.
```python
data = 'Hello World'
print(data)
# Hello World

data = "Don't you know \"Python\"?"
print(data)
# Don't you know "Python"?
```
## 문자열 연산
- 문자열 변수에 덧셈을 이용하면 문자열이 더해져서 연결 된다.
- 문자열 변수를 특정한 양의 정수와 곱하는 경우 문자열이 그 값만큼 여러번 더해진다
- 문자열에 대해서도 마찬가지로 인덱싱과 슬라이싱을 이용할 수 있다.
  - 다만 문자열은 특정 인덱스의 값을 변경할수는 없다.(Immutable)

```python
a = "Hello"
b = "World"
print(a + " " + b)
# Hello World

a = "String"
print(a * 3)
# StringStringString

a = "ABCDEF"
print(a[2 : 4])
# CD
```

## 튜플자료형
- 리스트와 유사하지만 다음과 같은 문법적 차이가 있다.
  - 튜플은 한 번 선언된 값을 변경할 수 없다.
  - 리스트는 대괄호를 이용하지만, 튜플은 소괄호를 이용한다.
- 튜플은 리스트에 비해 상대적으로 공간 효율적이다.

```python
a = (1,2,3,4,5,6,7,8,9)

# 네 번쨰 원소 출력
print(a[3])
# 4

# 두번째 원소부터 네번쨰 원소까지
print(a[1 :4])
# (2,3,4)

# 오류예제
a = (1,2,3,4)
print(a)
a[2] = 7
# Traceback (most recent call last):
#   File "main.py", line 4 in <module>
#     a[2] =7
# TypeError: 'tuple' object does not support item assignment
```

- 튜플 사용하면 좋은 경우
  - 서로 다른 성질의 데이터를 묶어서 관리해야할 때
    - 최단 경로 알고리즘에서는 (비용,노드 번호)의 형태로 튜플 자료형을 자주 사용
  - 데이터의 나열을 해싱의 키 값으로 사용해야할 때
    - 튜플은 변경이 불가능하므로 리스트와 다르게 키 값으로 사용될 수 있다.
  - 리스트보다 메모리를 효율적으로 사용해야 할 때

## 사전 자료형
- 키와 값의 쌍을 데이터로 가지는 자료형
  - 리스트나 튜플이 값을 순차적으로 저장하는 것과는 대비된다.
- 사전 자료형은 키와 값의 쌍을 데이터로 가지며, 원하는 변경불가능한 자료형을 키로 사용할 수 있다.
- 파이썬의 사전 자료형은 해시 테이블을 이용하므로 데이터의 조회 및 수정에 있어서 O(1) 상수시간에 처리할 수 있다.

```python
date = dict()
date['사과'] = 'Apple'
date['바나나'] = 'Banana'
date['코코넛'] = 'Coconut'

print(data)

if '사과' in data:
    print("'사과'를 키로 가지는 데이터가 존재합니다.")
# {'사과':'Apple' , '바나나':'Banana', '코코넛': 'Coconut'}
# '사과'를 키로 가지는 데이터가 존재합니다.
```
- 사전자료형 관련 메서드
  - 사전자료형에서는 키와 값을 별도로 뽑아내기 위한 메서드를 지원한다.
    - 키 데이터만 뽑아서 리스트로 이용할 때는 keys()함수 이용
    - 값 데이터만 뽑아서 리스트로 이용할 때는 vaules()함수 이용

```python
date = dict()
date['사과'] = 'Apple'
date['바나나'] = 'Banana'
date['코코넛'] = 'Coconut'

# 키 데이터만 담은 리스트
key_list = data.keys()

# 값 데이터만 담은 리스트
value_list = data.vvalues()
print(key_list)
print(value_list)
# dict_keys(['사과', '바나나' , '코코넛'])
# dict_values(['Apple', 'Banana', 'Coconut'])


# 각 키에 따른 값을 하나씩 출력
for key in key_list:
    print(date[key])
# Apple
# Banana
# Coconut
```

## 집합 자료형
- 중복을 허용하지 않는다.
- 순서가 없다.
- 집합은 리스트 혹은 문자열을 이용해서 초기화할 수 있다.
  - 이때 set()함수를 이용
- 혹은 중괄호 안에 각 원소를 콤마를 기준으로 구분하여 삽입함으로써 초기화할 수 있다.
- 데이터의 조회 및 수정에 있어서 O(1) 상수시간의 시간에 처리할 수 있다.

```python
# 집합 자료형 초기화 방법1
data = set([1,1,2,3,4,4,5])
print(data)
# {1,2,3,4,5}

# 집합 자료형 초기화 방법2
data = {1,1,2,3,4,4,5}
print(data)
# {1,2,3,4,5}
```

- 집합자료형의 연산
  - 합집함
    - 집합 A에 속하거나 B에 속하는 원소로 이루어진 집합
  - 교집합
    - 집합 A에도 속하고 B에도 속하는 원소로 이루어진 집합
  - 차집합
    - 집합 A의 원소 중에서 속하지 않는 원소들로 이루어진 집

```python
a = set([1,2,3,4,5])
b = set([3,4,5,6,7])

# 합집합
print(a | b)
# {1,2,3,4,5,6,7}

# 교집합
print(a & b)
# {3,4,5}

# 차집합
print(a - b)
# {1,2}
```
- 집합 자료형 관련 함수
```python
data = set([1,2,3])
print(data)
# {1,2,3}

# 새로운 원소 추가
data.add(4)
print(data)
# {1,2,3,4}

# 새로운 원소 여러개 추가
data.update([5,6])
print(data)
# {1,2,3,4,5,6}

# 특정한 값을 갖는 원소 삭제
data.remove(3)
print(data)
# {1,2,4,5,6}
```
- 사전자료형과 집합 자료형의 특징
  - 리스트나 튜플은 순서가 있기 때문에 인덱싱을 통해 자료형의 값을 얻을 수 있다.
  - 사전자료형과 집합자료형은 순서가 없기 때문에 인덱싱으로 값을 얻을 수 없다.
    - 사전의 키 혹은 집합의 원소를 이용해 O(1)상수시간의 시간 복잡도로 조회한다.